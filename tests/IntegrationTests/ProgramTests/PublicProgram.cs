// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace StarKid.Generated;

internal partial class StarKidProgram
{
    public static ref string p_currCmdName => ref _currCmdName;
    public static ref string p_prevCmdName => ref _prevCmdName;

    public static ref Action<string>[] p_posArgActions => ref _posArgActions;
    public static ref Action<string> p_addParams => ref _addParams;
    public static ref int p_requiredArgsMissing => ref _requiredArgsMissing;

    public static ref bool p_hasParams => ref _hasParams;
    public static ref string p_helpString => ref _helpString;
    public static ref Func<int> p_invokeCmd => ref _invokeCmd;

    public static ref Func<string, string?, bool, bool> p_tryExecFlag => ref _tryExecFlag;
    public static ref Func<string, string?, bool, bool> p_tryExecOption => ref _tryExecOption;
    public static ref Func<string, bool> p_tryUpdateCmd => ref _tryUpdateCmd;

    public static ref bool p_displayHelp => ref _displayHelp;

    public static ref string[] pargv => ref argv;
    public static ref int pargvIdx => ref argvIdx;

    public static Func<int> pNonInvokableGroupAction => NonInvokableGroupAction;


    // +==============+
    // | ARG HANDLING |
    // +==============+

    /// <summary>
    /// In case the option is separated from its value/argument by a space, it will be the next
    /// item in argv. This function tries to extract it, when possible
    /// </summary>
    public static bool pTryGetNextArgFromArgv([NotNullWhen(true)] out string? nextArg)
        => TryGetNextArgFromArgv(out nextArg);

    public static ref int pposArgIdx => ref posArgIdx;
    public static ref int p_paramsCount => ref _paramsCount;

    public static Action<string> pDefaultParamsAdd => DefaultParamsAdd;

    public static bool pTryAddPosArg(string arg)
        => TryAddPosArg(arg);


    // +==========+
    // | PRINTING |
    // +==========+

    public static Lazy<bool> pisNoColorEnvVarSet => isNoColorEnvVarSet;
    public static bool pIsColorOnErrorAllowed() => IsColorOnErrorAllowed();

    public static string pInRed(string msg) => InRed(msg);

    public static string pInBold(string msg) => InBold(msg);

    public static string pFormatError(string reason, params object[] objs) => FormatError(reason, objs);

    // +=========+
    // | PARSING |
    // +=========+

    public delegate bool pBoolOut<T>(string arg, out T t);

    public static T pThrowIfTryParseNotTrue<T>(pBoolOut<T> tryParse, string arg)
        => ThrowIfTryParseNotTrue(new BoolOut<T>(tryParse), arg);

    public static Nullable<T> pThrowIfTryParseNotTrue<T>(pBoolOut<Nullable<T>> tryParse, string arg) where T : struct
        => ThrowIfTryParseNotTrue(new BoolOut<Nullable<T>>(tryParse), arg);

    public static T pThrowIfParseError<T>(Func<string, T> parse, string arg)
        => ThrowIfParseError(parse, arg);

    public static Nullable<T> pThrowIfParseError<T>(Func<string, Nullable<T>> parse, string arg) where T : struct
        => ThrowIfParseError(parse, arg);

    public static bool pAsBool(string? val) => AsBool(val);

    public static bool pAsBool(string? val, bool defaultVal) => AsBool(val, defaultVal);

    public static bool pTryParseEnum<T>(string str, out T val) where T : struct, Enum
        => TryParseEnum(str, out val);

    public static T pWrapParseEnum<T>(string str) where T : struct, Enum
        => WrapParseEnum<T>(str);


    // +============+
    // | VALIDATION |
    // +============+

    public static void pThrowOptionAlreadySpecified(string optName)
        => ThrowOptionAlreadySpecified(optName);

    public static T pThrowIfNotValid<T>(T val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "")
        => ThrowIfNotValid(val, isValid, argName, message, funcName);

    public static T pThrowIfNotValid<T>(T val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "")
        => ThrowIfNotValid(val, isValid, argName, message, funcExpr);

    public static T? pThrowIfNotValidNullable<T>(T? val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "")
        => ThrowIfNotValidNullable(val, isValid, argName, message, funcName);

    public static Nullable<T> pThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Action<T> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcName = ""
    ) where T : struct
        => ThrowIfNotValidNullable(val, isValid, argName, message, funcName);

    public static T? pThrowIfNotValidNullable<T>(T? val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "")
        => ThrowIfNotValidNullable(val, isValid, argName, message, funcExpr);

    public static Nullable<T> pThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Func<T, bool> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcExpr = ""
    ) where T : struct
        => ThrowIfNotValidNullable(val, isValid, argName, message, funcExpr);


    // +======+
    // | MISC |
    // +======+

    public static string p_defaultExceptionMsg => _defaultExceptionMsg;
    public static bool pIsDefaultException(Exception e)
        => IsDefaultException(e);

    public static string pGetFriendlyNameOf(Type t)
        => GetFriendlyNameOf(t);
}
