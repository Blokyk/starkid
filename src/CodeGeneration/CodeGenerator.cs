#pragma warning disable RCS1197 // Optimize StringBuilder call

using StarKid.Generator.CommandModel;

namespace StarKid.Generator.CodeGeneration;

internal sealed partial class CodeGenerator(StarKidConfig _config)
{
    /// <summary>
    /// Generates the full source code for a group's command descriptor (CmdDesc)
    /// </summary>
    /// <param name="rootGroup">The command group to generate the CmdDesc's source code of</param>
    /// <param name="requiredNamespaces">The list of namespaces required by the types used in the group</param>
    /// <param name="config">The current generator config</param>
    /// <remarks>
    ///     The generated source code uses file-scoped constructs, which could interfere
    ///     with each other if put in the same parsing unit.
    /// </remarks>
    public static string ToSourceCode(Group rootGroup, ImmutableArray<string> requiredNamespaces, StarKidConfig config) {
        var generator = new CodeGenerator(config);
        var sb = new StringBuilder();

        generator.AddRootHeader(sb, rootGroup, requiredNamespaces);
        generator.AddSourceCode(sb, rootGroup);
        generator.AddRootFooter(sb, rootGroup);

        return sb.ToString();
    }

    internal const string FILE_HEADER = @"
// <auto-generated/>
#nullable enable
using System;
using System.Linq;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

";

    void AddRootHeader(StringBuilder sb, Group rootGroup, ImmutableArray<string> externalUsings) {
        sb.Append(FILE_HEADER);

        sb.Append(CodegenHelpers.GenerateUsingsHeaderCode(externalUsings));

sb.Append(@"

namespace StarKid.Generated;

internal
#if !__STARKID_TESTING_NON_STATIC_PROGRAM
    static
#endif
partial class StarKidProgram
{
    static void Initialize() => ").Append(rootGroup.ID).AppendLine("CmdDesc.Activate();");
    }

    void AddRootFooter(StringBuilder sb, Group _)
        => sb.AppendLine("}"); // class StarKidProgram

    /// <summary>
    ///     Generates the lookup function for an invokable's options (or flags,
    ///     if <c><paramref name="isFlags"/></c> is set)
    /// </summary>
    /// <param name="isFlags"></param>
    void AddOptionLookup(StringBuilder sb, InvokableBase groupOrCmd, bool isFlags) {
        string funcName = isFlags ? "TryExecFlagAction" : "TryExecOptionAction";

        sb.Append(@"
        internal static bool ").Append(funcName).Append("(string optName, string? arg, bool onlyAllowGlobal) ");

        // if we didn't find the option here, it might be global, so we ask the parent group
        var defaultReturn
            = groupOrCmd.ParentGroup is null
            ? "false"
            : groupOrCmd.ParentGroup.ID + "CmdDesc." + funcName + "(optName, arg, true)";

        IEnumerable<Option> opts = isFlags ? groupOrCmd.Flags : groupOrCmd.Options;
        // if there's no options, just return false
        if (!opts.Any()) {
            sb.Append("=> ").Append(defaultReturn).AppendLine(";");
            return;
        }

        sb.AppendLine("{");

        if (!isFlags) {
            sb.AppendLine("""
            void updateArg() {
                if (arg is null && !TryGetNextArgFromArgv(out arg))
                    ExitWithError("Option '--{0}' needs an argument", optName);
            }
""");
        }

        sb.Append(@"
            if (_displayHelp)
                return true;

            try {
                switch (optName) {");

        foreach (var opt in opts) {
            sb.Append(@"
                case ""--").Append(opt.Name).AppendLine("\":");
            if (opt.Alias != '\0') {
                sb.Append(@"
                case ""-").Append(opt.Alias).AppendLine("\":");
            }

            if (!opt.IsGlobal) {
                // add a guard against using this option globally
                //
                // it's fine to exit early because there can't be a
                // parent global option with the same name anyway
                sb.Append(@"
                    if (onlyAllowGlobal) return false;");
            }

            // for options, we might need to parse the argument from argv
            if (!isFlags) {
                sb.Append(@"
                    updateArg();");
            }

            sb.Append(@"
                    ").Append(opt.BackingSymbol.Name).AppendLine(@"Action(arg!);
                    return true;");
        }

        sb.Append(@"
                default:
                    return ").Append(defaultReturn).Append(';');
        sb.AppendLine("""

                }
            } catch (Exception e) {
                if (_displayHelp)
                    return true;

                if (arg is null) {
                    // arg is only null when it's a flag (although we could get a flag with a non-null arg)
                    ExitWithError(
                        "Using the '" + optName + "' flag isn't valid in this context: {0}",
                        e.Message
                    );
                } else {
                    ExitWithError(
                        "Expression '{0}' is not a valid value for option '" + optName + "': {1}",
                        arg, e.Message
                    );
                }

                return false;
            }
        }
""");
    }

    public void AddOptionFieldAndSetter(StringBuilder sb, Option opt, InvokableBase groupOrCmd) {
        if (groupOrCmd is not Group) {
            sb.Append(@"
        private static ").Append(opt.Type.FullName).Append(" @").Append(opt.BackingSymbol.Name);

            if (opt.DefaultValueExpr is not null) {
                sb
                .Append(" = ")
                .Append(opt.DefaultValueExpr);
            }

            sb
            .Append(';')
            .AppendLine();
        }

        var isOptRepeatable = opt.IsRepeatableOption();

        var expr = CodegenHelpers.GetFullExpression(opt);

        string stmt;
        if (isOptRepeatable) {
            sb.Append(@"
        private static List<").Append(opt.Parser.TargetType.FullName).Append("> ")
            .Append(opt.BackingSymbol.Name).Append("Builder = new();");

            stmt = opt.BackingSymbol.Name + "Builder.Add(" + expr + ")";
        } else {
            var fieldPrefix
                = groupOrCmd is Group group
                ? "@" + group.FullClassName + ".@"
                : "@";

            stmt = fieldPrefix + opt.BackingSymbol.Name + " = " + expr;
        }

        var actionName = opt.BackingSymbol.Name + "Action";
        var argType = opt is Flag ? "string?" : "string";

        if (!isOptRepeatable && !_config.AllowRepeatingOptions) {
            sb
            .Append(@"
        private static bool has").Append(actionName).Append("BeenTriggered;");
        }

        // internal static void {optName}Action(string[?] __arg) {
        //     if (has{optName}ActionBeenTriggered)
        //         ThrowOptionAlreadySpecified("{optName}");
        //     has{optName}ActionBeenTriggered = true;
        //     Validate(Parse(__arg));
        // }

        sb
            .Append(@"
        internal static void ").Append(actionName).Append('(').Append(argType).Append(" __arg) {");

        if (!isOptRepeatable && !_config.AllowRepeatingOptions) {
            sb
                .Append(@"
            if (has").Append(actionName).Append("BeenTriggered)")
                .Append(@"
                ThrowOptionAlreadySpecified(""--").Append(opt.Name).Append("\");")
                .Append(@"
            has").Append(actionName).Append("BeenTriggered = true;");
        }

        sb
            .Append(@"
            ").Append(stmt).AppendLine(@";
        }");
    }

    void AddFlushBuildersFunc(StringBuilder sb, InvokableBase invokable) {
        sb.Append(@"
        internal static void FlushState() {
            ");

        // if there's any parent, flush them first
        if (invokable.ParentGroup is not null)
            sb.Append(invokable.ParentGroup.ID).AppendLine(@"CmdDesc.FlushState();
            ");

        var fieldPrefix
            = invokable is Group group
            ? "@" + group.FullClassName + ".@"
            : "@";

        foreach (var opt in invokable.Options) {
            if (!opt.IsRepeatableOption())
                continue;

            var validatingExpr = CodegenHelpers.GetValidatingExpression(
                opt.BackingSymbol.Name + "Builder",
                opt.Name,
                opt.Type.IsNullable,
                opt.Validators.Where(v => !v.IsElementWiseValidator)
            );

            // if there's no custom arg name, just say "invalid values for option '--foo'"
            // however, if there *is* a custom name, say "invalid {name} values for option '--foo'"
            string errorFmtStart, valuesName;
            if (opt.CustomArgName is null) {
                errorFmtStart = "Invalid values";
                valuesName = "";
            } else {
                errorFmtStart = "Invalid {0} values";
                valuesName = opt.CustomArgName;
            }

            sb.Append(@"try {
                ").Append(fieldPrefix).Append(opt.BackingSymbol.Name).Append(" = ")
                .Append(validatingExpr).Append(@".ToArray();
            } catch (Exception e) {
                if (_displayHelp)
                    return;

                ExitWithError(
                    """).Append(errorFmtStart).Append(" for option '--").Append(opt.Name).Append(@"': {1}"",
                    """).Append(valuesName).Append(@""", e.Message
                );

                return;
            }");
        }

        sb.Append(@"
        }");
    }

    void AddActivateFunc(StringBuilder sb) =>
        sb.Append(@"
        internal static void Activate() {
            StarKidProgram._prevCmdName = _currCmdName;
            StarKidProgram._tryExecOption = TryExecOptionAction;
            StarKidProgram._tryExecFlag = TryExecFlagAction;
            StarKidProgram._tryUpdateCmd = TryUpdateCommand;
            StarKidProgram._addParams = _addParams;
            StarKidProgram._hasParams = _hasParams;
            StarKidProgram._posArgActions = _posArgActions;
            StarKidProgram._requiredArgsMissing = _requiredArgCount;
            StarKidProgram._invokeCmd = _invokeCmd;
            StarKidProgram._helpString = _helpText;
            StarKidProgram._currCmdName = __name;
        }");
}