#pragma warning disable RCS1197 // Optimize StringBuilder call

using StarKid.Generator.CommandModel;

namespace StarKid.Generator.CodeGeneration;

internal sealed partial class CodeGenerator(StarKidConfig _config)
{
    private readonly HelpGenerator _helpGenerator = new(_config);

    /// <summary>
    /// Generates the full source code for a group's command descriptor (CmdDesc)
    /// </summary>
    /// <param name="rootGroup">The command group to generate the CmdDesc's source code of</param>
    /// <param name="requiredNamespaces">The list of namespaces required by the types used in the group</param>
    /// <param name="config">The current generator config</param>
    /// <remarks>
    ///     The generated source code uses file-scoped constructs, which could interfere
    ///     with each other if put in the same parsing unit.
    /// </remarks>
    public static string ToSourceCode(Group rootGroup, ImmutableArray<string> requiredNamespaces, StarKidConfig config) {
        var generator = new CodeGenerator(config);
        var sb = new StringBuilder();

        generator.AddRootHeader(sb, rootGroup, requiredNamespaces);
        generator.AddSourceCode(sb, rootGroup);
        generator.AddRootFooter(sb, rootGroup);

        return sb.ToString();
    }

    void AddRootHeader(StringBuilder sb, Group rootGroup, ImmutableArray<string> externalUsings) {
        sb.Append(@"
// <auto-generated/>
#nullable enable
using System;
using System.Linq;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

");

        sb.Append(CodegenHelpers.GenerateUsingsHeaderCode(externalUsings));

sb.Append(@"

namespace StarKid.Generated;

internal static partial class StarKidProgram
{
    static void Initialize() => ").Append(rootGroup.ID).AppendLine("CmdDesc.Activate();");
    }

    void AddRootFooter(StringBuilder sb, Group _)
        => sb.AppendLine("}"); // class StarKidProgram

    /// <summary>Generates the <c>_helpText</c> field containing the invokable's help</summary>
    void AppendHelpTextField(StringBuilder sb, InvokableBase groupOrCmd) {
        var helpTextSb = new StringBuilder();
        _helpGenerator.AddHelpText(helpTextSb, groupOrCmd);

        sb.Append(@"
        internal const string _helpText = ").Append(SymbolDisplay.FormatLiteral(helpTextSb.ToString(), quote: true)).Append(';')
        .AppendLine();
    }

    /// <summary>
    ///     Generates the lookup function for an invokable's options (or flags,
    ///     if <c><paramref name="isFlags"/></c> is set)
    /// </summary>
    /// <param name="isFlags"></param>
    void AddOptionLookup(StringBuilder sb, InvokableBase groupOrCmd, bool isFlags) {
        string funcName = isFlags ? "TryExecFlagAction" : "TryExecOptionAction";

        sb.Append(@"
        internal static bool ").Append(funcName).Append("(string optName, string? arg, bool onlyAllowGlobal) ");

        // if we didn't find the option here, it might be global, so we ask the parent group
        var defaultReturn
            = groupOrCmd.ParentGroup is null
            ? "false"
            : groupOrCmd.ParentGroup.ID + "CmdDesc." + funcName + "(optName, arg, true)";

        IEnumerable<Option> opts = isFlags ? groupOrCmd.Flags : groupOrCmd.Options;
        // if there's no options, just return false
        if (!opts.Any()) {
            sb.Append(" =>").Append(defaultReturn).AppendLine(";");
            return;
        }

        sb.AppendLine("{");

        if (!isFlags) {
            sb.AppendLine("""
            void updateArg() {
                if (arg is null && !TryGetNextArgFromArgv(out arg))
                    ExitWithError("Option '--{0}' needs an argument", optName);
            }
""");
        }

        sb.Append(@"
            if (_displayHelp)
                return true;

            try {
                switch (optName) {");

        foreach (var opt in opts) {
            sb.Append(@"
                case ""--").Append(opt.Name).AppendLine("\":");
            if (opt.Alias != '\0') {
                sb.Append(@"
                case ""-").Append(opt.Alias).AppendLine("\":");
            }

            if (!opt.IsGlobal) {
                // add a guard against using this option globally
                //
                // it's fine to exit early because there can't be a
                // parent global option with the same name anyway
                sb.Append(@"
                    if (onlyAllowGlobal) return false;");
            }

            // for options, we might need to parse the argument from argv
            if (!isFlags) {
                sb.Append(@"
                    updateArg();");
            }

            sb.Append(@"
                    ").Append(opt.BackingSymbol.Name).AppendLine(@"Action(arg!);
                    return true;");
        }

        sb.Append(@"
                default:
                    return ").Append(defaultReturn).Append(';');
        sb.AppendLine("""

                }
            } catch (Exception e) {
                if (_displayHelp)
                    return true;

                if (arg is null) {
                    // arg is only null when it's a flag (although we could get a flag with a non-null arg)
                    ExitWithError(
                        "Using the '" + optName + "' flag isn't valid in this context: {0}",
                        e.Message
                    );
                } else {
                    ExitWithError(
                        "Expression '{0}' is not a valid value for option '" + optName + "': {1}",
                        arg, e.Message
                    );
                }

                return false;
            }
        }
""");
    }

    public void AddOptionFieldAndSetter(StringBuilder sb, Option opt, InvokableBase groupOrCmd) {
        if (groupOrCmd is not Group) {
            sb
            .Append("\t\tprivate static ")
            .Append(opt.Type.FullName)
            .Append(" @")
            .Append(opt.BackingSymbol.Name);

            if (opt.DefaultValueExpr is not null) {
                sb
                .Append(" = ")
                .Append(opt.DefaultValueExpr);
            }

            sb
            .Append(';')
            .AppendLine();
        }

        var fieldPrefix
            = groupOrCmd is Group group
            ? "@" + group.FullClassName + ".@"
            : "@";

        string expr
            = fieldPrefix + opt.BackingSymbol.Name + " = " + CodegenHelpers.GetFullExpression(opt);

        var actionName = opt.BackingSymbol.Name + "Action";
        var argType = opt is Flag ? "string?" : "string";

        if (!_config.AllowRepeatingOptions) {
            sb
            .Append(@"
        private static bool has").Append(actionName).Append("BeenTriggered;");
        }

        // internal static void {optName}Action(string[?] __arg) {
        //     if (has{optName}ActionBeenTriggered)
        //         ThrowOptionAlreadySpecified("{optName}");
        //     has{optName}ActionBeenTriggered = true;
        //     Validate(Parse(__arg));
        // }

        sb
            .Append(@"
        internal static void ").Append(actionName).Append('(').Append(argType).Append(" __arg) {");

        if (!_config.AllowRepeatingOptions) {
            sb
                .Append(@"
            if (has").Append(actionName).Append("BeenTriggered)")
                .Append(@"
                ThrowOptionAlreadySpecified(""--").Append(opt.Name).Append("\");")
                .Append(@"
            has").Append(actionName).Append("BeenTriggered = true;");
        }

        sb
            .Append(@"
            ").Append(expr).AppendLine(@";
        }");
    }

    void AddActivateFunc(StringBuilder sb) =>
        sb.Append(@"
        internal static void Activate() {
            StarKidProgram._prevCmdName = _currCmdName;
            StarKidProgram._tryExecOption = TryExecOptionAction;
            StarKidProgram._tryExecFlag = TryExecFlagAction;
            StarKidProgram._tryUpdateCmd = TryUpdateCommand;
            StarKidProgram._addParams = _addParams;
            StarKidProgram._hasParams = _hasParams;
            StarKidProgram._posArgActions = _posArgActions;
            StarKidProgram._requiredArgsMissing = _requiredArgCount;
            StarKidProgram._invokeCmd = _invokeCmd;
            StarKidProgram._helpString = _helpText;
            StarKidProgram._currCmdName = __name;
        }");
}