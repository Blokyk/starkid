// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace StarKid.Generated;

[EditorBrowsable(EditorBrowsableState.Never)]
[StackTraceHidden]
internal
#if !__STARKID_TESTING_NON_STATIC_PROGRAM
    static
#endif
partial class StarKidProgram
{
#pragma warning disable CS8618
    static StarKidProgram() => Initialize();
#pragma warning restore CS8618

    private static string _currCmdName = "";
    private static string _prevCmdName = "";

    private static Action<string>[] _posArgActions;
    private static Action<string> _addParams;
    private static int _requiredArgsMissing;

    public static bool _hasParams;
    private static string _helpString;
    private static Func<int> _invokeCmd;

    private static Func<string, string?, bool, bool> _tryExecFlag;
    private static Func<string, string?, bool, bool> _tryExecOption;
    private static Func<string, bool> _tryUpdateCmd;

    private static bool _displayHelp = false;

    private static string[] argv;
    private static int argvIdx;

    static int Main(string[] args) {
        Initialize();
        argv = args;
        var argCount = 0;

        var onlyArgs = false; // set to true if we get '--'

        bool argsContainHelp() {
            foreach (var rawArg in StarKidProgram.argv) {
                // either it's exactly '-h' or it's something like '-h=foo' (and idem for '--help')
                if (rawArg.StartsWith("-h", StringComparison.Ordinal) && (rawArg.Length == 2 || rawArg[2] == '='))
                    return true;
                if (rawArg.StartsWith("--help", StringComparison.Ordinal) && (rawArg.Length == 6 || rawArg[6] == '='))
                    return true;
            }

            return false;
        }

        _displayHelp = argsContainHelp();

        for (; argvIdx < StarKidProgram.argv.Length; argvIdx++) {
            ref var rawArg = ref StarKidProgram.argv[argvIdx];

            var eqIdx = rawArg.IndexOf('=');

            string arg;
            string? value = null;

            if (eqIdx < 0) {
                arg = rawArg;
            } else {
                arg = rawArg.Substring(0, eqIdx);
                value = rawArg.Substring(eqIdx + 1); // eqIdx + 1 ignores the '='
            }

            bool mightBeOpt = false;

            if (!onlyArgs) {
                if (arg.Length > 1 && arg[0] == '-') {
                    if (arg.Length == 2 && arg[1] == '-') {
                        onlyArgs = true;
                        continue;
                    }

                    mightBeOpt = true;

                    if (_displayHelp && (arg == "--help" || arg == "-h")) {
                        // in case --help got an argument, then treat it as trying to get
                        // the help text fot the corresponding command; if it's a valid
                        // command, update the parser state so that we'll display the
                        // right help text, and fallback on the current text if it's not
                        // a valid command
                        if (value is not null || TryGetNextArgFromArgv(out value))
                            _ = _tryUpdateCmd(value);

                        return DisplayHelpAndExit();
                    }

                    if (_tryExecFlag(arg, value, false))
                        continue;

                    if (_tryExecOption(arg, value, false))
                        continue;

                    if (_displayHelp)
                        continue;
                }
                else if (_tryUpdateCmd(arg)) {
                    if (!_displayHelp && value is not null)
                        return ExitWithError("'{0}' is trying to assign a value to a command", 1, rawArg);
                    continue;
                }
            }

            if (TryAddPosArg(arg))
                argCount++;
            else if (mightBeOpt)
                return PrintHelpString("Command '" + _currCmdName + "' doesn't have any option named '{0}'", arg);
            else
                return PrintHelpString("Couldn't understand '{0}' in this context", rawArg);
        }

        if (_displayHelp)
            return DisplayHelpAndExit();

        if (_requiredArgsMissing > 0)
            return ExitWithError("Expected at least {0} arguments, but only got {1}", _requiredArgsMissing + argCount, argCount);

        return _invokeCmd();
    }

    static readonly Func<int> NonInvokableGroupAction = () =>
        PrintHelpString(
            "Can't use '{0}' without a subcommand",
            _currCmdName
        );


    // +==============+
    // | ARG HANDLING |
    // +==============+

    /// <summary>
    /// In case the option is separated from its value/argument by a space, it will be the next
    /// item in argv. This function tries to extract it, when possible
    /// </summary>
    static bool TryGetNextArgFromArgv([NotNullWhen(true)] out string? nextArg) {
        if (argv.Length == (argvIdx + 1)) {
            // cf TryDoAction
            // note that here, we only "escape"/ignore after we know there's an error,
            // cause if we don't consume the next argument, we might misinterpret everything
            // afterward
            if (_displayHelp) {
                nextArg = "";
                return true;
            }

            nextArg = null;
            return false;
        }

        nextArg = argv[++argvIdx];
        return true;
    }

    private static int posArgIdx = 0;
    private static int _paramsCount = 0;
    internal static int ArgCount => posArgIdx + _paramsCount;
    internal static int ArgSlotsLeft => _posArgActions.Length - posArgIdx;

    static readonly Action<string> DefaultParamsAdd = _ =>
        throw new InvalidOperationException(
            "Something went wrong while trying to understand your command line. Please fill a report at https://github.com/blokyk/starkid/issues/new"
        );

    static bool TryAddPosArg(string arg) {
        if (_displayHelp)
            return true;

        if (ArgSlotsLeft > 0) {
            try {
                _posArgActions[posArgIdx++](arg);
                _requiredArgsMissing--;
                return true;
            } catch (EnvironmentExitException) {
                throw;
            } catch (Exception e) {
                ExitWithError(
                    "Expression '{0}' is not a valid value for this argument: {1}",
                    arg, e.Message
                );
                return false;
            }
        } else {
            if (!_hasParams)
                return false;

            _addParams(arg);
            _paramsCount++;
            return true;
        }
    }


    // +==========+
    // | PRINTING |
    // +==========+

    static readonly Lazy<bool> isNoColorEnvVarSet = new(() => Environment.GetEnvironmentVariable("NO_COLOR") is not null or "" or "0" or "false", false);
    static bool IsColorOnErrorAllowed()
        => !Console.IsErrorRedirected && !isNoColorEnvVarSet.Value;

    static string InRed(string msg)
        => !IsColorOnErrorAllowed() ? msg : "\x1b[31m" + msg + "\x1b[39m";

    static string InBold(string msg)
        => !IsColorOnErrorAllowed() ? msg : "\x1b[1m" + msg + "\x1b[22m";

    static string FormatError(string reason, params object[] objs)
        => InRed(string.Format(reason, objs.Select(o => InBold(o.ToString()!)).ToArray()));

    public static int ExitWithError(string msg) {
        Console.Error.WriteLine(InRed(msg));
        Environment.Exit(1);
        return 1;
    }

    public static int ExitWithError(string fmt, params object[] objs) {
        Console.Error.WriteLine(FormatError(fmt, objs));
        Environment.Exit(1);
        return 1;
    }

    public static int PrintHelpString(string reason) {
        Console.Error.WriteLine(InRed(reason));
        return DisplayHelpAndExit();
    }

    public static int PrintHelpString(string reason, params object[] objs) {
        Console.Error.WriteLine(FormatError(reason, objs));
        return DisplayHelpAndExit();
    }

    internal static int DisplayHelpAndExit() {
        Console.Error.WriteLine(_helpString);
        Environment.Exit(1);
        return 1;
    }


    // +=========+
    // | PARSING |
    // +=========+

    private delegate bool BoolOut<T>(string arg, out T t);

    private static T ThrowIfTryParseNotTrue<T>(BoolOut<T> tryParse, string arg) {
        if (!tryParse(arg, out var val))
            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'");

        return val;
    }

    private static Nullable<T> ThrowIfTryParseNotTrue<T>(BoolOut<Nullable<T>> tryParse, string arg) where T : struct {
        if (!tryParse(arg, out var val))
            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'");

        return val;
    }

    private static T ThrowIfParseError<T>(Func<string, T> parse, string arg) {
        try {
            return parse(arg);
        } catch (EnvironmentExitException) {
            throw;
        } catch (Exception e) when (IsDefaultException(e)) {
            throw new FormatException(
                "Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'"
            );
        } catch (Exception e) {
            throw new FormatException(
                "Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "': " + e.Message
            );
        }
    }

    private static Nullable<T> ThrowIfParseError<T>(Func<string, Nullable<T>> parse, string arg) where T : struct {
        try {
            return parse(arg);
        } catch (EnvironmentExitException) {
            throw;
        } catch (Exception e) when (IsDefaultException(e)) {
            throw new FormatException(
                "Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'"
            );
        } catch (Exception e) {
            throw new FormatException(
                "Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "': " + e.Message
            );
        }
    }

    private static bool AsBool(string? val) => AsBool(val, true);

    private static bool AsBool(string? val, bool defaultVal) {
        if (val is null)
            return defaultVal;

        if (val is "true" or "True" or "1")
            return true;

        if (val is "false" or "False" or "0")
            return false;

        throw new FormatException("Couldn't understand '" + val + "' as a boolean value");
    }

    private static bool TryParseEnum<T>(string str, out T val) where T : struct, Enum {
        if (str.Length == 0) {
            val = default(T);
            return false;
        }

        unchecked {
            uint offsetFirstChar = (uint)(str[0] - '0');
            if (offsetFirstChar <= '9' - '0' || offsetFirstChar is (uint)('-' - '0')) {
                val = default(T);
                return false;
            }
        }

        return System.Enum.TryParse<T>(str, ignoreCase: true, out val);
    }

    private static T WrapParseEnum<T>(string str) where T : struct, Enum {
        if (!TryParseEnum<T>(str, out var val))
            throw new FormatException($"'{str}' isn't a valid {typeof(T).Name} value");
        return val;
    }


    // +============+
    // | VALIDATION |
    // +============+

    private static void ThrowOptionAlreadySpecified(string optName)
        => ExitWithError("Option '{0}' has already been specified", optName);

    private static T ThrowIfNotValid<T>(T val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        try {
            isValid(val);
        }
        catch (EnvironmentExitException) {
            throw;
        }
        catch (Exception) when (message != null) {
            throw new Exception(message);
        } catch {
            // if there's no message, the caller will handle the exception itself
            throw;
        }

        return val;
    }

    private static T? ThrowIfNotValidNullable<T>(T? val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        try {
            if (val is not null)
                isValid(val);
        }
        catch (EnvironmentExitException) {
            throw;
        }
        catch (Exception) when (message != null) {
            throw new Exception(message);
        } catch {
            throw;
        }

        return val;
    }

    private static Nullable<T> ThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Action<T> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcName = ""
    ) where T : struct {
        try {
            if (val.HasValue)
                isValid(val.Value);
        }
        catch (EnvironmentExitException) {
            throw;
        }
        catch (Exception) when (message != null) {
            throw new Exception(message);
        } catch {
            throw;
        }

        return val;
    }

    private static Nullable<T> ThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Action<Nullable<T>> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcName = ""
    ) where T : struct {
        try {
            isValid(val);
        }
        catch (EnvironmentExitException) {
            throw;
        }
        catch (Exception) when (message != null) {
            throw new Exception(message);
        } catch {
            throw;
        }

        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "") {
        if (!isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' was false");

        return val;
    }

    private static T? ThrowIfNotValidNullable<T>(T? val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "") {
        if (val is not null && !isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' was false");

        return val;
    }

    private static Nullable<T> ThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Func<T, bool> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcExpr = ""
    ) where T : struct {
        if (val.HasValue && !isValid(val.Value))
            throw new Exception(message ?? "'" + funcExpr + "' was false");

        return val;
    }

    private static Nullable<T> ThrowIfNotValidNullable<T>(
        Nullable<T> val,
        Func<Nullable<T>, bool> isValid,
        string argName,
        string? message,
        [CallerArgumentExpression("isValid")] string funcExpr = ""
    ) where T : struct {
        if (!isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' was false");

        return val;
    }


    // +======+
    // | MISC |
    // +======+

    private static readonly string _defaultExceptionMsg = "Exception of type 'System.Exception' was thrown.";
    static bool IsDefaultException(Exception e) {
        return String.IsNullOrEmpty(e.Message) || e.Message == _defaultExceptionMsg;

        // we might enable this some day, but right now I feel like it might "erase" some
        // typed exceptions and I think that's a bit unfortunate

        // if (String.IsNullOrEmpty(e.Message))
        //    return true;
        //
        // var msg = e.Message.AsSpan();
        //
        // if (msg == _defaultExceptionMsg)
        //    return true;
        //
        // var typeName = e.GetType().ToString().AsSpan(); // that's what System.Exception uses
        //
        // return msg.StartsWith("Exception of type '")
        //     && msg[19..(19+typeName.Length)] == typeName
        //     && msg[(19+typeName.Length)..] == "' was thrown.";
    }

    private static string GetFriendlyNameOf(Type t) {
        if (t.IsArray) {
            var itemName = GetFriendlyNameOf(t.GetElementType()!);

            var rank = t.GetArrayRank();

            return rank == 1
                ? itemName + "[]"
                : itemName + "[" + new string(',', rank - 1) + "]";
        }

        if (!t.IsGenericType) {
            var name = t.Name;

            return name switch {
                "Int32"   => "int",
                "String"  => "string",
                "Single"  => "float",
                "Object"  => "object",
                "Boolean" => "bool",
                "Char"    => "char",
                "Byte"    => "byte",
                "Int16"   => "short",
                "UInt16"  => "ushort",
                "UInt32"  => "uint",
                "Int64"   => "long",
                "UInt64"  => "ulong",
                "Double"  => "double",
                _ => name
            };
        }

        static Type[] getTypeArgsOrParams(Type t)
            => t.IsConstructedGenericType
            ? t.GenericTypeArguments
            : t.GetGenericArguments();

        var typeArgsAsArray = getTypeArgsOrParams(t);
        var typeArgsCount = typeArgsAsArray.Length;

        var typeArgs = (IEnumerable<Type>)typeArgsAsArray;

        // if it's Outer.Inner<>, we don't have to special case anything
        if (t.IsNested && (t.DeclaringType!.IsConstructedGenericType || t.DeclaringType!.ContainsGenericParameters)) {
            // note: the arity of the outer type adds up with the inner's arity
            //      - typeof(Outer<>.Inner).GenericArgs.Length == 1
            //      - typeof(Outer<>.Inner<>).GenericArgs.Length == 2
            //
            // when you write:
            //      class Outer<T> { class Inner<M> { } }
            // it gets compiled to:
            //      .class Inner`1<T, M>

            var outer = t.DeclaringType;
            var outerArgs = getTypeArgsOrParams(outer);

            typeArgsCount = typeArgsCount - outerArgs.Length;

            // if Inner isn't generic, it'll have the same arity as Outer
            if (typeArgsCount == 0)
                return t.Name; // returns "Inner"

            // if inner IS generic, we ignore the first $outer.arity params
            // and then the normal logic applies

            typeArgs = typeArgs.Skip(outerArgs.Length);
        } else {
            // * this bit of code only cares about non-nested types
            // typeArgs == typeArgsAsArray
            if (t.IsConstructedGenericType) {
                if (t.Name == typeof(Nullable<>).Name)
                    return GetFriendlyNameOf(typeArgsAsArray[0]) + "?";
                else if (t.Name
                    is "ValueTuple`1" or "ValueTuple`2" or "ValueTuple`3" or "ValueTuple`4"
                    or "ValueTuple`5" or "ValueTuple`6" or "ValueTuple`7" or "ValueTuple`8"
                    or "Tuple`1" or "Tuple`2" or "Tuple`3" or "Tuple`4"
                    or "Tuple`5" or "Tuple`6" or "Tuple`7" or "Tuple`8"
                )
                    return '(' + String.Join(", ", typeArgsAsArray.Select(GetFriendlyNameOf)) + ')';
            }
        }

        // remove the `N at the end of generic type name
        var baseName = t.Name[..^(typeArgsCount < 10 ? 2 : 3)];

        return baseName + "<" + string.Join(", ", typeArgs.Select(GetFriendlyNameOf)) + ">";
    }

    // for starkid's tests
    internal class EnvironmentExitException : Exception {
        public int ExitCode { get; }
        public EnvironmentExitException(int exitCode) => ExitCode = exitCode;
    }
}
