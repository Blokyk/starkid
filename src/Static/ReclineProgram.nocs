// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Recline.Generated;

[EditorBrowsable(EditorBrowsableState.Never)]
[StackTraceHidden]
internal static partial class ReclineProgram
{
    private static string _currCmdName = "";
    private static string _prevCmdName = "";

    private static Action<string>[] _posArgActions;
    private static Action<string> _addParams;
    private static int _requiredArgsMissing;

    public static bool _hasParams;
    private static string _helpString;
    private static Func<int> _invokeCmd;

    private static Func<string, string?, bool, bool> _tryExecFlag;
    private static Func<string, string?, bool, bool> _tryExecOption;
    private static Func<string, bool> _tryUpdateCmd;

    private static bool _displayHelp = false;

    private static string[] argv;
    private static int argvIdx;

    static int Main(string[] args) {
        argv = args;
        var argCount = 0;

        var onlyArgs = false; // set to true if we get '--'

        bool argsContainHelp() {
            foreach (var rawArg in ReclineProgram.argv) {
                // either it's exactly '-h' or it's something like '-h=foo' (and idem for '--help')
                if (rawArg.StartsWith("-h", StringComparison.Ordinal) && (rawArg.Length == 2 || rawArg[2] == '='))
                    return true;
                if (rawArg.StartsWith("--help", StringComparison.Ordinal) && (rawArg.Length == 6 || rawArg[6] == '='))
                    return true;
            }

            return false;
        }

        _displayHelp = argsContainHelp();

        for (; argvIdx < ReclineProgram.argv.Length; argvIdx++) {
            ref var rawArg = ref ReclineProgram.argv[argvIdx];

            var eqIdx = rawArg.IndexOf('=');

            string arg;
            string? value = null;

            if (eqIdx < 0) {
                arg = rawArg;
            } else {
                arg = rawArg.Substring(0, eqIdx);
                value = rawArg.Substring(eqIdx + 1); // eqIdx + 1 ignores the '='
            }

            bool mightBeOpt = false;

            if (!onlyArgs) {
                if (arg.Length > 1 && arg[0] == '-') {
                    if (arg.Length == 2 && arg[1] == '-') {
                        onlyArgs = true;
                        continue;
                    }

                    mightBeOpt = true;

                    if (_displayHelp && (arg == "--help" || arg == "-h")) {
                        // in case --help got an argument, then treat it as trying to get
                        // the help text fot the corresponding command; if it's a valid
                        // command, update the parser state so that we'll display the
                        // right help text, and fallback on the current text if it's not
                        // a valid command
                        if (value is not null || TryGetNextArgFromArgv(out value))
                            _ = _tryUpdateCmd(value);

                        return DisplayHelpAndExit();
                    }

                    if (_tryExecFlag(arg, value, false))
                        continue;

                    if (_tryExecOption(arg, value, false))
                        continue;

                    if (_displayHelp)
                        continue;
                }
                else if (_tryUpdateCmd(arg)) {
                    if (!_displayHelp && value is not null)
                        return ExitWithError("'{0}' is trying to assign a value to a command", 1, rawArg);
                    continue;
                }
            }

            if (TryAddPosArg(arg))
                argCount++;
            else if (mightBeOpt)
                return PrintHelpString("Command '" + _currCmdName + "' doesn't have any option named '{0}'", arg);
            else
                return PrintHelpString("Couldn't understand '{0}' in this context", rawArg);
        }

        if (_displayHelp)
            return DisplayHelpAndExit();

        if (_requiredArgsMissing > 0)
            return ExitWithError("Expected at least {0} arguments, but only got {1}", _requiredArgsMissing + argCount, argCount);

        return _invokeCmd();
    }

    static readonly Func<int> NonInvokableGroupAction = () =>
        PrintHelpString(
            "Can't use '{0}' without a sub-command",
            _currCmdName
        );


    // +==============+
    // | ARG HANDLING |
    // +==============+

    /// <summary>
    /// In case the option is separated from its value/argument by a space, it will be the next
    /// item in argv. This function tries to extract it, when possible
    /// </summary>
    static bool TryGetNextArgFromArgv([NotNullWhen(true)] out string? nextArg) {
        if (argv.Length == (argvIdx + 1)) {
            // cf TryDoAction
            // note that here, we only "escape"/ignore after we know there's an error,
            // cause if we don't consume the next argument, we might misinterpret everything
            // afterward
            if (_displayHelp) {
                nextArg = "";
                return true;
            }

            nextArg = null;
            return false;
        }

        nextArg = argv[++argvIdx];
        return true;
    }

    private static int posArgIdx = 0;
    private static int _paramsCount = 0;
    internal static int ArgCount => posArgIdx + _paramsCount;
    internal static int ArgSlotsLeft => _posArgActions.Length - posArgIdx;

    static readonly Action<string> DefaultParamsAdd = _ =>
        throw new InvalidOperationException(
            "Something went wrong while trying to understand your command line. Please fill a report at https://github.com/blokyk/recline/issues/new"
        );

    static bool TryAddPosArg(string arg) {
        if (_displayHelp)
            return true;

        if (ArgSlotsLeft > 0) {
            try {
                _posArgActions[posArgIdx++](arg);
                _requiredArgsMissing--;
                return true;
            } catch (EnvironmentExitException) {
                throw;
            } catch (Exception e) {
                ExitWithError(
                    "Expression '{0}' is not a valid value for this argument: {1}",
                    arg, e.Message
                );
                return false;
            }
        } else {
            if (!_hasParams)
                return false;

            _addParams(arg);
            _paramsCount++;
            return true;
        }
    }


    // +==========+
    // | PRINTING |
    // +==========+

    static readonly Lazy<bool> isNoColorEnvVarSet = new(() => Environment.GetEnvironmentVariable("NO_COLOR") is not null or "" or "0" or "false", false);
    static bool IsColorOnErrorAllowed()
        => !Console.IsErrorRedirected && !isNoColorEnvVarSet.Value;

    static string InRed(string msg)
        => !IsColorOnErrorAllowed() ? msg : "\x1b[31m" + msg + "\x1b[39m";

    static string InBold(string msg)
        => !IsColorOnErrorAllowed() ? msg : "\x1b[1m" + msg + "\x1b[22m";

    static string FormatError(string reason, params object[] objs)
        => InRed(string.Format(reason, objs.Select(o => InBold(o.ToString()!)).ToArray()));

    public static int ExitWithError(string msg) {
        Console.Error.WriteLine(InRed(msg));
        Environment.Exit(1);
        return 1;
    }

    public static int ExitWithError(string fmt, params object[] objs) {
        Console.Error.WriteLine(FormatError(fmt, objs));
        Environment.Exit(1);
        return 1;
    }

    public static int PrintHelpString(string reason) {
        Console.Error.WriteLine(InRed(reason));
        return DisplayHelpAndExit();
    }

    public static int PrintHelpString(string reason, params object[] objs) {
        Console.Error.WriteLine(FormatError(reason, objs));
        return DisplayHelpAndExit();
    }

    internal static int DisplayHelpAndExit() {
        Console.Error.WriteLine(_helpString);
        Environment.Exit(1);
        return 1;
    }


    // +=========+
    // | PARSING |
    // +=========+

    private delegate bool BoolOut<T>(string arg, out T t);

    private static T ThrowIfTryParseNotTrue<T>(BoolOut<T> tryParse, string arg) {
        if (!tryParse(arg, out var val))
            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'");

        return val;
    }

    private static T ThrowIfParseError<T>(Func<string, T> parse, string arg) {
        try {
            return parse(arg);
        } catch (Exception e) {
            var msg = e.Message is null ? "" : ": " + e.Message;

            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'" + msg);
        }
    }

    private static bool AsBool(string? val) => AsBool(val, true);

    private static bool AsBool(string? val, bool defaultVal) {
        if (val is null)
            return defaultVal;

        if (val is "true" or "True")
            return true;

        if (val is "false" or "False")
            return false;

        throw new FormatException("Couldn't understand '" + val + "' as a boolean value");
    }

    private static T WrapParseEnum<T>(string str) where T : struct {
        if (!System.Enum.TryParse<T>(str, ignoreCase: true, out var val))
            throw new FormatException($"'{str}' isn't a valid {typeof(T).Name} value");
        return val;
    }


    // +============+
    // | VALIDATION |
    // +============+

    private static void ThrowOptionAlreadySpecified(string optName)
        => ExitWithError("Option '{0}' has already been specified", optName);

    private static T ThrowIfNotValid<T>(T val, Func<T, string?> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        var errorMessage = isValid(val);

        if (!String.IsNullOrEmpty(errorMessage))
            throw new Exception(errorMessage);

        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        try {
            isValid(val);
        } catch (Exception) when (message != null) { // if there's no message, the caller will handle the exception itself
            throw new Exception(message);
        }

        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "") {
        if (!isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' returned false");

        return val;
    }

    private static T? ThrowIfNotValidNullable<T>(T? val, Func<T, string?> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        if (val is null)
            return val;

        var errorMessage = isValid(val);

        if (!String.IsNullOrEmpty(errorMessage))
            throw new Exception(errorMessage);

        return val;
    }

    private static T? ThrowIfNotValidNullable<T>(T? val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        try {
            if (val is not null)
                isValid(val);
        } catch (Exception) when (message != null) {
            throw new Exception(message);
        }

        return val;
    }

    private static T? ThrowIfNotValidNullable<T>(T? val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "") {
        if (val is not null && !isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' returned false");

        return val;
    }


    // +======+
    // | MISC |
    // +======+

    private static string GetFriendlyNameOf(Type t) {
        if (t.IsArray) {
            return GetFriendlyNameOf(t.GetElementType()!) + "[]";
        }

        if (!t.IsGenericType) {
            return t.Name switch {
                "Char"   => "char",
                "Byte"   => "byte",
                "Int16"  => "short",
                "UInt16" => "ushort",
                "Int32"  => "int",
                "UInt32" => "uint",
                "Int64"  => "long",
                "UInt64" => "ulong",
                "String" => "string",
                _        => t.Name
            };
        }

        if (t.IsConstructedGenericType) {
            if (t.Name == typeof(Nullable<>).Name)
                return GetFriendlyNameOf(t.GenericTypeArguments[0]) + "?";
            else if (t.Name
                is "ValueTuple`1" or "ValueTuple`2" or "ValueTuple`3" or "ValueTuple`4"
                or "ValueTuple`5" or "ValueTuple`6" or "ValueTuple`7" or "ValueTuple`8"
                or "Tuple`1" or "Tuple`2" or "Tuple`3" or "Tuple`4"
                or "Tuple`5" or "Tuple`6" or "Tuple`7" or "Tuple`8"
            )
                return '(' + String.Join(", ", t.GenericTypeArguments.Select(GetFriendlyNameOf)) + ')';
        }

        var baseName = t.Name[..^(t.GenericTypeArguments.Length < 10 ? 2 : 3)];

        return baseName + "<" + string.Join(',', t.GenericTypeArguments.Select(GetFriendlyNameOf)) + ">";
    }
}