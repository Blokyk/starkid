// <auto-generated/>
#nullable enable

using System;
using System.Linq;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Recline.Generated;

[EditorBrowsable(EditorBrowsableState.Never)]
[StackTraceHidden]
internal static partial class ReclineProgram
{
#pragma warning disable CS8618
    static ReclineProgram() {
        TryUpdateCommand((CmdID)0);
    }
#pragma warning restore CS8618

    private static string _currCmdName;
    private static string _prevCmdName = "";

    private static Action<string>[] _posArgActions = Array.Empty<Action<string>>();
    private static List<string> _params = new();

    public static bool _hasParams;
    private static string _helpString;
    private static Func<int> _invokeCmd;

    private static Dictionary<string, Action<string?>> _flags;
    private static Dictionary<string, Action<string>> _options;
    private static Dictionary<string, CmdID> _subs;

    private static bool _displayHelp = false;

    static int Main(string[] args) {
        var argCount = 0;

        var onlyArgs = false; // set to true if we get '--'

        if (args.Contains("-h") || args.Contains("--help"))
            _displayHelp = true;

        for (int i = 0; i < args.Length; i++) {
            ref var rawArg = ref args[i];

            var eqIdx = rawArg.IndexOf('=');

            string arg;
            string? value = null;

            if (eqIdx < 0) {
                arg = rawArg;
            } else {
                arg = rawArg.Substring(0, eqIdx);
                value = rawArg.Substring(eqIdx + 1); // eqIdx + 1 ignores the '='
            }

            if (!onlyArgs) {
                if (arg.Length > 1 && arg[0] == '-') {
                    if (arg.Length == 2 && arg[1] == '-') {
                        onlyArgs = true;
                        continue;
                    }

                    // fixme: we don't handle e.g. '--help=<cmd-name>' correctly
                    // this branch alievates the problem by at least not telling the
                    // users that '--help' isn't an existing option, but this is still
                    // pretty bad
                    if (arg == "--help" || arg == "-h") {
                        // in case --help got an argument, then treat it as trying to get
                        // the help text fot the corresponding command; if it's a valid
                        // command, update the parser state so that we'll display the
                        // right help text, and fallback on the current text if it's not
                        // a valid command
                        if (TryGetNextArgFromArgv(ref i, args, out value)
                        &&  _subs.TryGetValue(value, out var cmdID))
                            TryUpdateCommand(cmdID);

                        DisplayHelp();
                        return 1;
                    } else if (_flags.TryGetValue(arg, out var actFlag)) {
                        if (!TryDoAction(actFlag, arg, value, rawArg))
                            return 1;
                        continue;
                    }

                    if (_options.TryGetValue(arg, out var actOpt)) {
                        if (value is null) {
                            if (!TryGetNextArgFromArgv(ref i, args, out value)) {
                                PrintHelpString("Option {0} needs an argument", arg);
                                return 1;
                            }

                            rawArg += " " + value;
                        }

                        if (!TryDoAction(actOpt!, arg, value, rawArg))
                            return 1;
                        continue;
                    }

                    if (_displayHelp)
                        continue;

                    PrintHelpString("Command " + _currCmdName + " doesn't have any option named '{0}'", arg);
                    return 1;
                }

                if (_subs.TryGetValue(arg, out var subCmdID)) {
                    if (!_displayHelp && value is not null) {
                        PrintHelpString("Can't assign a value to subcommand {0}", arg);
                        return 1;
                    }

                    if (!TryUpdateCommand(subCmdID)) {
                        return 1;
                    }

                    continue;
                }
            }

            if (!TryAddPosArg(arg)) {
                // ^ already takes care of chechking _displayHelp
                PrintHelpString("Couldn't understand '{0}' in this context", rawArg);
                return 1;
            }
        }

        if (_displayHelp)
            return DisplayHelp();

        if (ArgSlotsLeft > 0) {
            PrintHelpString("Expected at least {0} arguments, but only got " + argCount, (ArgSlotsLeft + argCount).ToString());
            return 1;
        }

        return _invokeCmd();
    }

    static bool TryDoAction(Action<string?> act, string arg1, string? arg2, string rawArg) {
        // we don't want to potentially cause any errors if the user just wants to see the help
        // text
        if (_displayHelp)
            return true;

        try {
            act(arg2);
            return true;
        }
        catch (Exception e) {
            PrintHelpString(
                "Expression '{0}' is not valid in this context: \x1b[1m" + e.Message + "",
                rawArg
            );
            return false;
        }
    }

    /// <summary>
    /// In case the option is separated from its value/argument by a space, it will be the next
    /// item in argv. This function tries to extract it, when possible
    /// </summary>
    static bool TryGetNextArgFromArgv(ref int i, string[] args, [NotNullWhen(true)] out string? nextArg) {
        if (args.Length == (i + 1)) {
            // cf TryDoAction
            // note that here, we only "escape"/ignore after we know there's an error,
            // cause if we don't consume the next argument, we might misinterpret everything
            // afterward
            if (_displayHelp) {
                nextArg = "";
                return true;
            }

            nextArg = null;
            return false;
        }

        nextArg = args[++i];
        return true;
    }

    static int NonInvokableGroupAction() {
        PrintHelpString(
            "Can't use '{0}' without a sub-command",
            _currCmdName
        );

        return 1;
    }

    static string InRed(string msg)
        => "\x1b[31m" + msg + "\x1b[0m";

    static string FormatError(string reason, object obj1)
        => InRed(string.Format(reason, "\x1b[1m" + obj1.ToString() + "\x1b[22m"));

    public static void PrintHelpString(string reason) {
        Console.Error.WriteLine(InRed(reason));
        DisplayHelp();
    }

    public static void PrintHelpString(string reason, string argName)
        => PrintHelpString(FormatError(reason, argName));

    private static bool AsBool(string? val) => AsBool(val, true);

    private static bool AsBool(string? val, bool defaultVal) {
        if (val is null)
            return defaultVal;

        if (val is "true" or "True")
            return true;

        if (val is "false" or "False")
            return false;

        throw new FormatException("Couldn't understand '" + val + "' as a boolean value");
    }

    private static T WrapParseEnum<T>(string str) where T : struct {
        if (!System.Enum.TryParse<T>(str, ignoreCase: true, out var val))
            throw new FormatException($"'{str}' isn't a valid {typeof(T).Name} value");
        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Func<T, string?> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        var errorMessage = isValid(val);

        if (!String.IsNullOrEmpty(errorMessage))
            throw new Exception(errorMessage);

        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Action<T> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcName = "") {
        try {
            isValid(val);
        } catch (Exception) when (message != null) {
            throw new Exception(message);
        }

        return val;
    }

    private static T ThrowIfNotValid<T>(T val, Func<T, bool> isValid, string argName, string? message, [CallerArgumentExpression("isValid")] string funcExpr = "") {
        if (!isValid(val))
            throw new Exception(message ?? "'" + funcExpr + "' returned false");

        return val;
    }

    private delegate bool BoolOut<T>(string arg, out T t);

    private static T ThrowIfTryParseNotTrue<T>(BoolOut<T> tryParse, string arg) {
        if (!tryParse(arg, out var val))
            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'");

        return val;
    }

    private static T ThrowIfParseError<T>(Func<string, T> parse, string arg) {
        try {
            return parse(arg);
        } catch (Exception e) {
            var msg = ": " + e.Message;

            throw new FormatException("Couldn't parse '" + (arg ?? "") + "' as an argument of type '" + GetFriendlyNameOf(typeof(T)) + "'" + msg);
        }
    }

    private static string GetFriendlyNameOf(Type t) {
        if (t.IsArray) {
            return GetFriendlyNameOf(t.GetElementType()!) + "[]";
        }

        if (!t.IsGenericType) {
            return t.Name switch {
                "Char"   => "char",
                "Byte"   => "byte",
                "Int16"  => "short",
                "UInt16" => "ushort",
                "Int32"  => "int",
                "UInt32" => "uint",
                "Int64"  => "long",
                "UInt64" => "ulong",
                "String" => "string",
                _        => t.Name
            };
        }

        if (t.IsConstructedGenericType) {
            if (t.Name == typeof(Nullable<>).Name)
                return GetFriendlyNameOf(t.GenericTypeArguments[0]) + "?";
            else if (t.Name
                is "ValueTuple`1" or "ValueTuple`2" or "ValueTuple`3" or "ValueTuple`4"
                or "ValueTuple`5" or "ValueTuple`6" or "ValueTuple`7" or "ValueTuple`8"
                or "Tuple`1" or "Tuple`2" or "Tuple`3" or "Tuple`4"
                or "Tuple`5" or "Tuple`6" or "Tuple`7" or "Tuple`8"
            )
                return '(' + String.Join(", ", t.GenericTypeArguments.Select(GetFriendlyNameOf)) + ')';
        }

        var baseName = t.Name[..^(t.GenericTypeArguments.Length < 10 ? 2 : 3)];

        return baseName + "<" + string.Join(',', t.GenericTypeArguments.Select(GetFriendlyNameOf)) + ">";
    }

    private static int posArgIdx = 0;
    internal static int ArgCount => posArgIdx + _params.Count;
    internal static int ArgSlotsLeft => _posArgActions.Length - posArgIdx;

    internal static bool TryAddPosArg(string arg) {
        if (_displayHelp)
            return true;

        if (ArgSlotsLeft > 0) {
            try {
                _posArgActions[posArgIdx++](arg);
                return true;
            } catch (Exception e) {
                PrintHelpString(
                    "Expression '{0}' is not a valid value for this argument: \x1b[1m" + e.Message + "\x1b[22m",
                    arg
                );
                return false;
            }
        } else {
            if (!_hasParams)
                return false;

            _params.Add(arg);
            return true;
        }
    }

    internal static int DisplayHelp() {
        Console.Error.WriteLine(_helpString);
        Environment.Exit(1);
        return 1;
    }
}