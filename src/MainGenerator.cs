using StarKid.Generator.Model;

namespace StarKid.Generator;

[Generator(LanguageNames.CSharp)]
public partial class MainGenerator : IIncrementalGenerator
{
    private static readonly string _cmdGroupAttributeName = typeof(CommandGroupAttribute).FullName!;

    private static readonly string _starkidProgramCode;

    static MainGenerator() {
        _starkidProgramCode = Utils.GetStaticResource("StarKidProgram.nocs");

        var sb = new StringBuilder();

        sb.AppendLine(@"
#define GEN
#nullable enable
// <auto-generated/>

using System;

");

        var attribs = new[] {
            "CommandGroupAttribute",
            "CommandAttribute",
            "OptionAttribute",
            "ParseWithAttribute",
            "ValidateWithAttribute"
        };

        foreach (var name in attribs)
            sb.AppendLine(Utils.GetStaticResource("Attributes." + name + ".cs"));

        _attributeCode = sb.ToString();
    }

    private static readonly string _attributeCode;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(
            static postInitCtx =>
                postInitCtx.AddSource(
                    "StarKid_Attributes.g.cs",
                    SourceText.From(_attributeCode, Encoding.UTF8)
                )
        );

        var langVersionSource
            = context
                .CompilationProvider
                .Select(
                    (comp, _) => (comp as CSharpCompilation)?.LanguageVersion ?? LanguageVersion.Default
                );

    #if DEBUG
        var fawmnWarmup
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    _cmdGroupAttributeName,
                    (node, _) => node is ClassDeclarationSyntax,
                    (_, _) => 0
                )
                .Collect()
                .WithTrackingName("fawmn_warmup");

        context.RegisterSourceOutput(fawmnWarmup, (_, _) => { });
    #endif

        var usingsSource
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    _cmdGroupAttributeName,
                    (node, _) => node is ClassDeclarationSyntax,
                    (ctx, _) => GetReachableNamespaceNames((ctx.TargetNode as ClassDeclarationSyntax)!)
                )
                .SelectMany((arr, _) => arr)
                .Collect()
                .WithTrackingName("starkid_collect_usings");

        // todo: separate this into three pipelines:
        //      - ParseWith resolution with FAWMN (returns a map between symbol name and parser)
        //      - same with ValidateWith
        //      - Group building, like before
        // We can then bind parsers back to their original symbols by going through the whole
        // command tree (maybe have an variable for like "needs a parser/validator" so that
        // we don't lookup *every single symbol name*)
        //
        // do we also want to separate auto-parsers? the problem is that we need to do the group
        // building first, but we could the ParseWith
        // part after group_building, and have group_building output a list of stuff that needs
        // an auto-parser
        //
        // todo: we could also make another pipeline to get the xml docs and use a similar strategy to merge back
        // we'd have to do that for every symbol with either [Command], [CommandGroup], or [Option]
        var groupsSource
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    _cmdGroupAttributeName,
                    (node, _) => node is ClassDeclarationSyntax,
                    (ctx, _) => {
                        var wrapper = new DataAndDiagnostics<Group?>();
                        wrapper.Data = CreateGroup((INamedTypeSymbol)ctx.TargetSymbol, ctx.SemanticModel, wrapper.AddDiagnostic);
                        return wrapper;
                    }
                )
                .WithTrackingName("starkid_group_building");

        var groupTreeSource
            = groupsSource
                .Collect()
                .Select(
                    (groups, _) => {
                        var wrapper = new DataAndDiagnostics<Group?>();
                        wrapper.Data = BindGroups(groups.Select(g => g.Data), wrapper.AddDiagnostic);
                        return wrapper;
                    }
                )
                .WithTrackingName("starkid_binding");

        var globalConfigSource = context.AnalyzerConfigOptionsProvider.Select((opts, _) => opts.GlobalOptions);

        // todo: add custom comparers for each
        var combinedValueProvider
            = groupTreeSource
                .Combine(usingsSource)
            .Combine(globalConfigSource.Combine(langVersionSource));

        // Generate the source using the compilation and enums
        context.RegisterImplementationSourceOutput(
            combinedValueProvider,
            static (spc, groupTreeAndConfig)
                => GenerateFromData(
                        groupTreeAndConfig.Left.Left.Data,   // root group
                        groupTreeAndConfig.Left.Right,  // usings
                        groupTreeAndConfig.Right.Left,  // config
                        groupTreeAndConfig.Right.Right, // langVersion
                        spc
                )
        );

        var starkidDiagnosticSource
            = groupsSource
                .Append(groupTreeSource)
                .SelectMany((w, _) => w.GetDiagnostics())
                .Where(diag => diag.Id != Diagnostics.GiveUp.Id);

        context.RegisterSourceOutput(
            starkidDiagnosticSource,
            static (spc, diag) => spc.ReportDiagnostic(diag)
        );
    }

    internal static Group? CreateGroup(INamedTypeSymbol classSymbol, SemanticModel model, Action<Diagnostic> addDiagnostic) {
        var attrListBuilder = new AttributeListBuilder(addDiagnostic);

        static Group? bail() {
            SymbolInfoCache.FullReset();
            return null;
        }

        if (!GroupBuilder.TryCreateGroupFrom(classSymbol, attrListBuilder, model, addDiagnostic, out var group))
            return bail();

        return group;
    }

    internal static Group? BindGroups(IEnumerable<Group?> groups, Action<Diagnostic> addDiagnostic) {
        var classNames = new Dictionary<string, Group>(8); // ¯\_(ツ)_/¯

        // collect the names of the each group's class
        foreach (var group in groups) {
            if (group is null)
                return null;

            // if we have duplicate class names, it means an attribute
            // was repeated multiple times on the same class. That is pretty
            // likely to happen in user code, since we should assume it is
            // invalid most of the time; therefore might as well take the small
            //perf hit of an additional lookup (since we don't have Dictionary<T,U>.TryAdd
            // on ns2.0), and just ignore it, since we'd still like to bind as many
            // group as possible in any case
            if (classNames.ContainsKey(group.FullClassName))
                continue;

            classNames.Add(group.FullClassName, group);
        }

        Group? rootGroup = null;

        // for each group, find the group in which it was
        // contained and then add it as a subgroup to that parent

        foreach (var group in classNames.Values) {
            // a group is the root group if:
            //      (1) It is not a nested class
            //              => group.ParentClassFullName is null
            //   OR
            //      (2) Its parent class isn't marked with group
            //              => group.ParentClassFullName is not in classNames

            if (group.ParentClassFullName is null || !classNames.ContainsKey(group.ParentClassFullName)) {
                if (rootGroup is null) {
                    rootGroup = group;
                    continue;
                }

                // if there already was a root group, then
                addDiagnostic(
                    Diagnostic.Create(
                        Diagnostics.TooManyRootGroups,
                        Location.None,
                        rootGroup.FullClassName, group.FullClassName
                    )
                );

                return null;
            }

            classNames[group.ParentClassFullName].AddSubgroup(group);
        }

        if (rootGroup is not null)
            ValidateOptionTree(rootGroup, addDiagnostic);

        return rootGroup;
    }

    internal static void ValidateOptionTree(Group rootGroup, Action<Diagnostic> addDiagnostic) {
        void validate(Group group, HashSet<string> names, HashSet<char> aliases) {
            var groupOptions = group.OptionsAndFlags;
            var commandOptions = group.Commands.SelectMany(cmd => cmd.OptionsAndFlags);

            foreach (var option in groupOptions.Concat(commandOptions)) {
                var longNameExists
                    = option.IsGlobal
                    ? !names.Add(option.Name)
                    : names.Contains(option.Name);

                if (longNameExists) {
                    addDiagnostic(
                        Diagnostic.Create(
                            Diagnostics.OptNameAlreadyExists,
                            option.GetLocation(),
                            option.Name
                        )
                    );
                }

                if (option.Alias != default(char)) {
                    var aliasExists
                        = option.IsGlobal
                        ? !aliases.Add(option.Alias)
                        : aliases.Contains(option.Alias);

                    if (aliasExists) {
                        addDiagnostic(
                            Diagnostic.Create(
                                Diagnostics.OptAliasAlreadyExists,
                                option.GetLocation(),
                                option.Alias
                            )
                        );
                    }
                }
            }

            foreach (var sub in group.SubGroups) {
                // yes, we have to create new ones each time,
                // cause otherwise the .Add()s would carry
                // over between subs
                validate(sub, new(names), new(aliases));
            }
        }

        validate(rootGroup, new(), new());
    }

    /// <summary>
    /// Traverse a syntax node's ancestors to figure out the reachable namespaces
    /// from its position, either through using directives or namespace declarations.
    /// </summary>
    internal static ImmutableArray<string> GetReachableNamespaceNames(SyntaxNode classDec) {
        SyntaxNode? parent = classDec.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>();

        var usings = new List<UsingDirectiveSyntax>();

        var fullNamespaceNameParts = new List<string>();
        while (parent is BaseNamespaceDeclarationSyntax { Usings: var nsUsings } ns) {
            usings.AddRange(nsUsings);
            fullNamespaceNameParts.Add(ns.Name.ToString());
            parent = ns.Parent;
        }

        var unit = (parent ?? classDec).FirstAncestorOrSelf<CompilationUnitSyntax>();

        if (unit is not null)
            usings.AddRange(unit.Usings);

        var names = usings
            .Where(u => u.StaticKeyword == default && u.Name is not null)
            .Select(u => u.Name!.ToString());

        if (fullNamespaceNameParts.Count != 0)
            names = names.Append(String.Join(".", fullNamespaceNameParts.Reverse<string>())); // Reverse<T>() is IEnumerable, Reverse() is void

        return names.ToImmutableArray();
    }
}
