#pragma warning disable RCS1197 // Optimize StringBuilder call

using StarKid.Generator.Model;

namespace StarKid.Generator;

internal sealed partial class CodeGenerator
{
    private readonly StarKidConfig _config;

    private readonly HelpGenerator _helpGenerator;

    public CodeGenerator(StarKidConfig config) {
        _config = config;
        _helpGenerator = new(config);
    }

    public static string ToSourceCode(Group rootGroup, ImmutableArray<string> usings, StarKidConfig config) {
        var generator = new CodeGenerator(config);
        var sb = new StringBuilder();
        generator.AddRootHeader(sb, rootGroup, usings);
        generator.AddSourceCode(sb, rootGroup);
        generator.AddRootFooter(sb, rootGroup);
        return sb.ToString();
    }

    void AddRootHeader(StringBuilder sb, Group rootGroup, ImmutableArray<string> externalUsings) {
        sb.Append(@"
// <auto-generated/>
#nullable enable
");

        var usings
            = externalUsings
                .Concat(new[] {
                    "System",
                    "System.Linq",
                    "System.Diagnostics",
                    "System.Diagnostics.CodeAnalysis",
                    "System.Collections.Generic",
                    "System.Runtime.CompilerServices"
                })
                .Distinct();

        // it's fine cause we know they will always be one or more using (thanks to the built-ins)
        sb.Append("using ").AppendJoin(";\nusing ", usings).Append(';');

sb.Append(@"

namespace StarKid.Generated;

internal static partial class StarKidProgram
{
    static void Initialize() => ").Append(rootGroup.ID).AppendLine("CmdDesc.Activate();");
    }

    void AddRootFooter(StringBuilder sb, Group _)
        => sb.AppendLine("}"); // class StarKidProgram

    void AddOptionLookup(StringBuilder sb, InvokableBase groupOrCmd, bool isFlags) {
        string funcName = isFlags ? "TryExecFlagAction" : "TryExecOptionAction";

        sb.Append(@"
        internal static bool ").Append(funcName).AppendLine("(string optName, string? arg, bool onlyAllowGlobal) {");

        // if we didn't find the option here, it might be global, so we ask the parent group
        var defaultReturn
            = groupOrCmd.ParentGroup is null
            ? "false"
            : groupOrCmd.ParentGroup.ID + "CmdDesc." + funcName + "(optName, arg, true)";

        IEnumerable<Option> opts = isFlags ? groupOrCmd.Flags : groupOrCmd.Options;
        // if there's no options, just return false
        if (!opts.Any()) {
            sb.Append(" return ").Append(defaultReturn).AppendLine("; }");
            return;
        }

        if (!isFlags) {
            sb.Append("""
            void updateArg() {
                if (arg is null && !TryGetNextArgFromArgv(out arg))
                    ExitWithError("Option {0} needs an argument", 1, optName);
            }
""");
        }

        sb.Append(@"
            if (_displayHelp)
                return true;

            try {
                switch (optName) {");

        foreach (var opt in opts) {
            sb.Append(@"
                case ""--").Append(opt.Name).AppendLine("\":");
            if (opt.Alias != '\0') {
                sb.Append(@"
                case ""-").Append(opt.Alias).AppendLine("\":");
            }

            if (!opt.IsGlobal) {
                // add a guard against using this option globally
                //
                // it's fine to exit early because there can't be a
                // parent global option with the same name anyway
                sb.Append(@"
                    if (onlyAllowGlobal) return false;");
            }

            if (opt is not Flag) {
                sb.Append(@"
                    updateArg();");
            }

            sb.Append(@"
                    ").Append(opt.BackingSymbol.Name).AppendLine(@"Action(arg!);
                    return true;");
        }

        sb.Append(@"
                    default:
                        return ").Append(defaultReturn).Append(';');
        sb.Append("""

                }
            } catch (Exception e) {
                if (_displayHelp)
                    return true;

                if (arg is null) {
                    // arg is only null when it's a flag (although we could get a flag with a non-null arg)
                    ExitWithError(
                        "Using the '" + optName + "' flag isn't valid in this context: {0}",
                        e.Message
                    );
                } else {
                    ExitWithError(
                        "Expression '{0}' is not a valid value for option '" + optName + "': {1}",
                        arg, e.Message
                    );
                }

                return false;
            }
        }
""");
    }

    public void AddOptionFunction(StringBuilder sb, Option opt, InvokableBase groupOrCmd) {
        if (groupOrCmd is not Group) {
            sb
            .Append("\t\tprivate static ")
            .Append(opt.Type.FullName)
            .Append(" @")
            .Append(opt.BackingSymbol.Name);

            if (opt.DefaultValueExpr is not null) {
                sb
                .Append(" = ")
                .Append(opt.DefaultValueExpr);
            }

            sb
            .Append(';')
            .AppendLine();
        }

        var fieldPrefix
            = groupOrCmd is Group group
            ? "@" + group.FullClassName + ".@"
            : "@";

        string expr
            = fieldPrefix + opt.BackingSymbol.Name + " = " + CodegenHelpers.GetFullExpression(opt);

        var actionName = opt.BackingSymbol.Name + "Action";
        var argType = opt is Flag ? "string?" : "string";

        if (!_config.AllowRepeatingOptions) {
            sb
            .Append(@"
        private static bool has").Append(actionName).AppendLine("BeenTriggered;");
        }

        // internal static void {optName}Action(string[?] __arg) {
        //     if (has{optName}ActionBeenTriggered)
        //         ThrowOptionAlreadySpecified("{optName}");
        //     has{optName}ActionBeenTriggered = true;
        //     Validate(Parse(__arg));
        // }

        sb
            .Append(@"
        internal static void ").Append(actionName).Append('(').Append(argType).Append(" __arg) {");

        if (!_config.AllowRepeatingOptions) {
            sb
                .Append(@"
            if (has").Append(actionName).Append("BeenTriggered)")
                .Append(@"
                ThrowOptionAlreadySpecified(""--").Append(opt.Name).Append("\");")
                .Append(@"
            has").Append(actionName).Append("BeenTriggered = true;");
        }

        sb
            .Append(@"
            ").Append(expr).AppendLine(@";
        }");
    }

    void AddActivateFunc(StringBuilder sb) =>
        sb.Append(@"
        internal static void Activate() {
            StarKidProgram._prevCmdName = _currCmdName;
            StarKidProgram._tryExecOption = TryExecOptionAction;
            StarKidProgram._tryExecFlag = TryExecFlagAction;
            StarKidProgram._tryUpdateCmd = TryUpdateCommand;
            StarKidProgram._addParams = _addParams;
            StarKidProgram._hasParams = _hasParams;
            StarKidProgram._posArgActions = _posArgActions;
            StarKidProgram._requiredArgsMissing = _requiredArgCount;
            StarKidProgram._invokeCmd = _invokeCmd;
            StarKidProgram._helpString = _helpText;
            StarKidProgram._currCmdName = __name;
        }");
}